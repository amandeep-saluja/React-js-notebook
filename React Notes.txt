React is a javascript library and not a framework.

React class-2:

How to add react into our app:

We have to import the React library in our code by several ways:

1. add react js files from cdn using script tag
2. add react files using bundler

Bundlers: It is responsible for a lot of things in our app to make it production ready.
Like:
It makes our code:
-> Minified
-> Optimize code
-> Tree shaking
-> remove console log

Some recommended Bundlers available in market:
-> Webpack
-> Parcel
-> Vite

Parcel is a bundler package, that is used to bundle our code and make our app production ready.

Package manager: -> Package repository (NPM/yarn)
We need NPM package manager to pull parcel package into our code.

For creating package management file in our code, package.json to keep package manager configurations.
npm init -> will create new package.json file

npm install -D parcel

caret vs tilde

package-lock.json -> will lock the exact version of dependency

Install react package using npm
npm install -D react
npm install -D react-dom

How to ignite our app

npx parcel index.html


React class-3


JSX

Babel

	React.createElement => React object => HTML(DOM)

React Components:
	Functional Components
	Class based Components

Note:
		const heading = React.createElement("h1", {}, "Heading");

		const head = (
		  <div>
			{heading} //-> heading returns react object
		  </div>
		);


class-4

For breaking code into components and use it again we have to use something knows as import and export keywords.
Exporting from module:

	-> Named export: 	Can be multiple
	-> Default export:  Can only be one


Import from module:

	-> Named import: 	Can be multiple
	-> Default import:  Can only be one

example:

	import Header from './components/Header';

	import {Title} from './components/Header';

	This is not object destructuring.

If it is object destructuring, then we should be able to do this,,,

	import obj from './components/Header'

	const {Title} = obj; //not valid

	obj.Title // not valid

But we can do something like this ->

	import * as Obj from './components/Header';

	Obj.Title

So, React is a default export from react library.

For default imported element should not be necessary to be same name as default export name.

	import Head from './components/Header'; // this will work as Head denotes Header

Also, we can import both together as shown below:
	import Header, { Title } from "./components/Header";
Even,
	import Header, { Title } from "./components/Header.js";
	import Header, { Title } from "./components/Header.jsx";

We can also do this,
	import * as XYZ from "./components/Header";

	<XYZ.Header />

same as

	<React.Fragment></React.Fragment>
----------------------------------------

React uses one way data binding only

-------------------------------------------------------------
class-5/class-6
State variable or React hook

	react creates Virtual dom and to know react that something will change on an event, we attach a hook between data and virtual dom's element.
	So whenever there is an event triggered, react re-render that part of virtual dom or sub-tree that has used state variable...
	
	React Fiber -> new reconciliation algorithm

	while reconciliation react used diff algorithm to check difference between the virtual DOM's previous state and current state.

	React only watch it's state variables and re-render it in virtual dom.
	
useEffect is a react hook that calls when component is rendered.
	
useEffect callback function takes a call back funtion & dependency array...
and call it at a specific time.

after every rerender useEffect gets called and hence it's callback will be called

useEffect calls when:
	
	-> empty dependency array -> once after first render
	-> dep arrat [searchTxt] => once after initial render + everytime after render ( my searchTxt changes)
	-> if we don't pass any dependency -> it will be called after every render.
	
Never create any component inside component.
Never ever write a useState() inside if else. -> react wont like inconsistency. -> react won;t know if searchTxt variable will be there or not.
Never write a useState inside for loop.


react gives you useState to create local variable inside your component.
Never create a useState react variable outside component

Formik -> npm package used to create forms.

-------------------------------------------------------------------------------
class-7

createBrowserRouter -> function to create routers in our project -> and pass the routing configuration

createBrowserRouter-> it takes list of paths 

after creating the routing configuration, it just don't work unless we provide it to our app..

For this use, RouterProvider... and provide the routing configuration to it...

ErrorElement -> error component

Routing ->

	1. Client side routing
	2. Server side routing
----------------------------------------------------------------------------
Single Page Application (SPA):
To avoid the server side routing and eliminate the server side routing we will use the client side routing....

to load the components according to route dynamically we use outlet to fill in with child component.

All the childrens of my component go into the outlet according to route.

to use the params from routing path -> react-route-dom package provided us something known as useParams() hook.

modular
reusable
testable
readable
maintainable
-------------------------------------------------------------------------------------
class-8 - Let's get Classy
==========================

Routing
    -> How to make a route? -> react-router-dom
    -> Learn and try to use various ways to create routers:
        1. createBrowserRouter (Recommended)
        2. createHashRouter
        3. createMemoryRouter
    -> Nested route inside a route -> Children of children
    -> To render the nested child, an Outlet is to be created or child tag is need to be added in parent.

    -> If you want to create a route in continuation of parent route, don't add / before it.
    -> If u add / before a route, it will create a route from root.

    -> Outlet will render that component inside itself, which child component's route is open.

Routing children of children
	-> parentPath/{path} => localhost:1234/about/profile
	-> children component always rendered inside outlet and we need to create outlet inside it's parent...

Class based components:

	-> messy
	-> iff creating new project, recommended not to create class based component...
	-> non maintainable
	-> To make a class as react component class and not JS class, we use extends React.Component
	-> mandatory method to override is -> render() {}
	-> React watches for the change in props and re-renders the component.
	-> Just like Functional Component has state, CBC also has it's state.

	-> If we want to access the props inside constructor of CBC, we have to pass the props to super()
	    else we will not be able to access the props, and we get undefined.
	    This is because React have not assigned the props to the context (this) inside the constructor,
	    and even we are able to access the props inside the render method using this (context), this is because
	    React assigns the props to instance of the class explicitly after initializing it.
	    see below:
	    //React under the hood
        const instance = new DefinedComponent(props);
        instance.props = props;

	-> we receive props inside `this` keyword.
	-> we have to do this.props.{prop-name}
	-> to create state variables in react, we have to create it inside the constructor,
	    best place to create the state variable, is constructor of class, as the classes are invoked
	-> do not set state variable without set function else react does not know when to trigger reconciliation

React Life Cycle:

    -> useEffect is the best place to call the API, as it calls after the initial render completes.
    -> similarly componentDidMount() is the best place to call the API in CBC.

Order in which life cycle hooks of parent and child component will be triggered:
	Parent - constructor
	Parent - render 
	Child - constructor
	Child - render
	Child - Component did Mount
	Parent - Component did Mount

Order in which life cycle hooks of parent and 2 child components will be triggered:
    Parent - constructor
	Parent - render
        First Child - constructor
        First Child - render
        Second Child - constructor
        Second Child - render
        First Child - Component did Mount
        Second Child - Component did Mount
	Parent - Component did Mount

Lifecycle of React class component
    ->refer-Diagram
        https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

->React Render happens in two Phases
	1. Render phase
		-> calls constructor
		-> calls render -> create virtual DOM and ready to put everything on browser
						-> react batches up everything into one, (that's why if two child component's constructor is called just after render of first child)
	2. Commit phase
		-> React updates DOM & refs
		-> componentDidMount calls
	
componentDidMount will be called after initial render is finished, browser has the 
---------------------------------------------------------------------------------------------------------------
Parent Constructor                          ||
Parent render                               ||
	First Child constructor                 ||              Render Phase
	First Child render                      ||
	Second Child constructor                ||              This is the place where react renders all
	Second Child render                     ||              the child components at once.

----------------------------------------------------------------------------------------------------------------

	Every child's rendered on DOM           ||              This is the place where browser starts updating DOM
                                            ||
	First Child - componentDidMount         ||              Commit Phase
	Second Child - componentDidMount        ||
Parent componentDidMount                    ||              <- Best place to make API call
                                            ||                  as all the rendering and committing is complete.
----------------------------------------------------------------------------------------------------------------


Order in which life cycle hooks of parent and child components with async componentDidMount will be triggered:
---------------------------------------------------------------------------------------------------------------
    Parent - constructor                    ||
	Parent - render                         ||              Render phase
    Child - constructor                     ||              Mounting Cycle
    Child - render                          ||
---------------------------------------------------------------------------------------------------------------
    DOM is updated                          ||
	Parent - Component did Mount            ||              Commit Phase
    json is logged in console               ||              -> calls setState()
    Child - Component did Mount             ||              -> updates the state -> re-render the child component
---------------------------------------------------------------------------------------------------------------
    Child - render                          ||              Updating Cycle
    Child - componentDidUpdate              ||
---------------------------------------------------------------------------------------------------------------
    Parent - unmount                        ||              Unmounting cycle
    Child - unmount                         ||
---------------------------------------------------------------------------------------------------------------
due to async added in the componentDidMount of child component,
it loaded asynchronously and delays the load of it.

-> When componentDidMount will be called -> Once after first render
-> When componentDidUpdate will be called -> After every render

What that signifies -> It is similar behaviour like useEffect()

Research Homework:
Why to use super in constructor?
Why can I make componentDidMount async and not useEffect async?

-------------------------------------------------------------------------
class-9

How many times componentDidMount gets called? -> once

How many times componentDidUpdate gets called? -> after every state change

When componentDidUnmount called for ? -> for cleanup

Functional component -> It's a function that returns JSX

hooks -> It's a function that does not return JSX but other values
        useState - returns array
        useEffect - returns void

helper component
    -> to hold the reusable functions in utils

Custom Hooks
    useOnline

Lazy Loading
    -> Chunking
    -> Code splitting
    -> Dynamic Bundling
    -> Lazy loading
    -> On Demand Loading
    -> Dynamic Import

    -> It fails to load the component and suspends the rendering, as module takes time to load
    -> It's an SPA. It will not reload, but in second time it has the code loaded in browser and hence it works.

    -> To overcome this error, react gave us a component named Suspence from "react" package.
    -> It will take care of the loading of module and render

Never load the lazy loaded component inside another component.